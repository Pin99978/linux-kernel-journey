### explain

假設 在一個 4-bit 系統下的參數

最大正整數 TMax：7，其二進位表示為 0111。
最小負整數 TMin：-8，其二進位表示為 1000。

使用 tadd_ok 函式來測試一個會發生溢位的加法。
```c
int tadd_ok(int x , int y){
    int sum = x + y;
    return (sum - x == y) && (sum - y) == x;
}
```
假設
x = 7 (二進位 0111)
y = 1 (二進位 0001)

步驟一：加法溢位

sum = x + y;

  0111  (x = 7)
+ 0001  (y = 1)
-------
  1000 

計算出的位元模式是 1000。在我們 4 位元的有號系統中，1000 代表的值是 -8 (也就是 TMin)。

溢位發生：7 + 1 的結果應該是 8，但在這個系統中卻變成了 -8。正數加正數得到了負數，這就是典型的正向溢位。tadd_ok 函式理應要偵測到這個錯誤並回傳 false (0)。

步驟二：減法「反向」溢位

現在，函式會執行驗證 (sum - x == y)。
我們要計算 sum - x，也就是 -8 - 7。
在二補數系統中，減法是加上一個數的負值，所以運算是 -8 + (-7)。

首先，7 是 0111，那麼 -7 的二補數表示是：

0111 (7) -> 位元反轉 1000 -> 加一 1001。所以 -7 是 1001。

現在我們計算 -8 + (-7) 的二進位加法：

  1000  (sum = -8)
+ 1001  (-x = -7)
-------
 10001
因為我們的系統只有 4 位元，所以最左邊的第 5 位元（進位）會被丟棄。

最終的 4 位元結果是 0001，它的十進位值是 1。

驗證過程也溢位了：-8 - 7 的數學結果是 -15，但因為溢位（更準確地說是下溢 underflow），結果「繞回來」變成了 1。

步驟三：錯誤的結論

驗證表達式 (sum - x == y) 變成了 (1 == 1)。
這個結果是 true (1)。
因此，tadd_ok 函式在發生了嚴重溢位的情況下，依然錯誤地回傳了 true，判斷這個加法是「ok」的。